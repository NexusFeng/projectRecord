## 链接地址

https://nexusfeng.github.io/vue-table-scroll/

## 解决的痛点

- element ui 表格表体不支持无缝滚动
- vue-seamless-scroll 表格需要改造(拆分表头加表体,让表体滚动,多个项目需要重复写,当表格数据高度少于视口高度时,还是会出现滚动现象)

## 核心

- 利用单例模式创建全局的 tooltip
- `requestAnimationFrame`控制动画的流畅显示
- 原生 table 的 colgroup 来控制每列的宽度
- 利用Range对象(表示一个包含节点与文本节点的一部分的文档片段)来计算内容是否超出单元格以及定位当前内容在页面所处的位置

## 功能解析

前置工作

- 页面挂载后计算表体的宽度,添加至 header 数据中,与自定义宽度做一个合并
- 将设置 colgroup 中 col 宽度属性的方法提取为 mixin,当页面挂载后,获取到`col`标签为其设置`width`属性
- 将数据通过`prop`传给表头和表体

表体滚动

- 当页面挂载后,计算如果数据的总高度小于视口高度时,则不进行滚动方法,否则将表体数据复制一份
- 滚动通过`transform: translateY()`属性+计算属性实现,通过`requestAnimationFrame`不断改变位置,计算属性监听后更新视图

无缝滚动

- 计算表体的高度,如果滚动过的距离大于或等于表体高度将滚动过的距离置为0,之后滚动距离减去步长,然后不断自调用,创建一种无缝滚动的效果
- 步长控制这滚动的速度,步长越大,减的越多,滚动的越快

单步滚动(例如有十条数据,滚动一条数据,停顿一下,继续滚动)

- 进入函数时依旧计算表体的高度,如果滚动过的距离大于或等于表体高度将滚动过的距离置为0,之后滚动距离减去单步长
- 清除定时器
- 计算滚动过的距离与单条数据的高度的余数,如果小于单步长,则设置定时器调用自身,否则直接调用(假如滚过的距离是96,每条数据的高度是48,余数是0,单步长为6,则`0 < 6`,说明一条数据已经滚完,此时设置定时器,一段时间后再执行函数,所以设置步长最好是每条数据的高度的约数)

鼠标进入停止滚动

- 监听鼠标进入移除事件,当鼠标进入时,清除所有的定时器并取消`requestAnimationFrame`

鼠标滚轮无缝滚动

- 监听`mousewheel`事件,判断`event.wheelDelta`的值,如果大于0,证明鼠标滚轮向上滑,给滚动的距离不断加一定值,如果小于0,证明鼠标滚轮向上滑,给滚动的距离不断减一定值

超长提示(tooltip)  

**用element ui的`tooltip`问题,1.得引入element ui。2.当当前单元格内容没有超出时也会提示**
- 首先利用`querySelector`获取当前单元格的dom节点
- `range.setStart()`设置range的起点(参数为当前节点,偏移量为0),`range.setEnd()`设置range的终点(参数为当前节点,偏移量为当前节点的宽度)
- `range.getBoundingClientRect()`得到当前文本区域的视窗坐标(left: 文本区域左侧距离视窗左侧的距离,top: 文本区域上侧距离视窗顶部的距离,right: 文本区域右侧距离视窗左侧的距离, bottom: 文本区域下侧距离视窗顶部的距离),通过`width`属性可以拿到文本的长度,判断该长度大于当前单元格的长度,就证明该单元格需要设置`tooltip`
- 创建一个vue实例,调用`$mount()`生成dom节点,将其添加至`body`中,通过`display`控制显隐
- tooltip两部分组成,小三角和文本区域,距离顶部距离为`range.getBoundingClientRect().top`,距离左边距离为`range.getBoundingClientRect().left`,小三角距离左边距离为`range.getBoundingClientRect().left + 单元格长度的一半`让其处于中间位置

页面自适应
- 挂载组件时添加一个尺寸变化函数,当监听到函数变化时,调用`updateColumns`方法来更新表格列宽度
